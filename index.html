<!DOCTYPE html>
<html lang="en">

<head>
  <title>minibook R session</title>

  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  
  <style>
    body {
        font-family:Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New;
        font-weight: bold;
        font-size: 20px;
    }

    .RconsoleOutput {background-color: rgb(240, 20, 240, 0.2); }
    .RconsoleLine   {text-indent: 50px; }
    
    </style>
  
    <script type="text/javascript">

      var globalLastSeqno = -1;
      
      // press A, scroll to bottom. works. browsers are not
      // fighting this like they are the other scroll change.
      // window.addEventListener('keydown', e => {
      //     if (65 === e.keyCode) { // uppercase A
      //         window.scroll(0,99999);              
      //     }
      // }, false);

      function stamp() {
          var dt = new Date();
          //document.getElementById("datetime").innerHTML = dt.toLocaleString();
          document.getElementById("datetime").innerHTML = dt.toTimeString() + "   " + dt.toISOString();
      }
      
      function disableScroll() {
          // Get the current page scroll position
          scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,

          // if any scroll is attempted, set this to the previous value
          window.onscroll = function() {
              window.scrollTo(scrollLeft, scrollTop);
          };
      }

      function enableScroll() {
          window.onscroll = function() {};
      }
      
/**
 * Tries to connect to the reload service and start listening to reload events.
 *
 * @function tryConnectToReload
 * @public
 */
function tryConnectToReload(address) {
  var conn = new WebSocket(address);

  conn.onclose = function() {
    globalLastSeqno = -1;
    setTimeout(function() {
      tryConnectToReload(address);
    }, 2000);
  };

    conn.onmessage = function(evt) {
        console.log("onmessage: ", evt.data);

        // We send length prefixed messages, in case they get concatenated.
        // Break them up and append them separately here.
        var remain = evt.data;
        var colon = remain.indexOf(":")
        while (colon >= 0) {
            if (colon > 0) {
                var len = parseInt(remain.substring(0, colon).trim());
                var msg = remain.substring(colon+1, colon+1+len);
                appendLog(msg);
                remain = remain.substring(colon+2+len);
                colon = remain.indexOf(":");
            }
        }
      
        // If we uncomment this line, then the page will refresh every time a message is received.
        //location.reload()
        
        // After we return from this callback,
        // the scroll position is moved up from the bottom
        // where we had set it.
  };
}


function scrollToBottom() {
   window.scrollTo(0, document.body.scrollHeight);
}
//history.scrollRestoration = "manual";
window.onload = stamp;
//window.onready = scrollToBottom;

      function nextID() {
          var d  = document.getElementById("log");
          var n  = d.children.length;
          var id  = "log_" + n.toString();
          return id;
      }
      
 function appendLog(msg){
 
    console.log("msg = ", msg);
    
    const update = JSON.parse(msg)

    var d  = document.getElementById("log");
    
    // try to prevent duplicates due to websocket tomfoolery.
    if (update.seqno) {      
        if (update.seqno > globalLastSeqno) {
            // good keep it
            globalLastSeqno = update.seqno;
        } else {
           // drop duplicates
           console.log("dropping stale message update.seqno" + update.seqno + " vs. last " + globalLastSeqno);
           return;
        }
    }

    if (update.text) {
        var newstuff = '<div id="' + nextID() + '">' + update.text + '</div>';
        d.innerHTML += newstuff
        console.log("we added text")
    }

    // in theory the command and the output could arrive together, so
    // print the console output after the text of the command.
    if (update.console) {
        var newstuff = '<div id="' + nextID() + '" class="RconsoleOutput"><br/>';
        for (let i = 0; i < update.console.length; i++) {
            newstuff += '<div class="RconsoleLine">' + update.console[i] + '</div><br/>';
        }
        d.innerHTML += newstuff + '<br/>';
        console.log("we added console output")
    }

    if (update.image) {
        var hash = "";
        if (update.pathhash) {
           hash = update.pathhash;
        }
        var newstuff = '<div id="'+ nextID() +'" style="max-width: 800px"><img src="http://rog:8080/images/' + update.image + '?pathhash=' + hash + '" style="max-width:100%;"/></div>';
        d.innerHTML += newstuff        
    }
    

    // scroll to the bottom to show the latest output.
    // 
    // 2 msec isn't long enough to win the fight for the scrollbar
    // position, usually. but 20 msec seems to win it consistently.
    //
    setTimeout(function() { console.log("called back!"); scrollToBottom()}, 20);
}

try {
  if (window["WebSocket"]) {
    // The reload endpoint is hosted on a statically defined port.
    try {
      tryConnectToReload("ws://rog:12450/reload");
    }
    catch (ex) {
      // If an exception is thrown, that means that we couldn't connect to to WebSockets because of mixed content
      // security restrictions, so we try to connect using wss.
      tryConnectToReload("wss://rog:12451/reload");
    }
  } else {
    console.log("Your browser does not support WebSockets, cannot connect to the Reload service.");
  }
} catch (ex) {
  console.error('Exception during connecting to Reload:', ex);
}
</script>
</head>

<body>
  <p>#R minibook started: <span id="datetime"></span></p>
  <hr>
  <div id="log"> </div>
</body>

</html>
